#pragma once
//
#define WIN32_LEAN_AND_MEAN             // 从 Windows 头文件中排除极少使用的内容

#include <windows.h>					// Windows 头文件
//
#include <stdlib.h>
//
#include <stdint.h>
//
#include "TSConfig_UE4TypeByBase.h"
//
#include "TSConfig_UE4TypeByUI.h"

#ifndef TSCONFIG_UE4TYPE_H
#define TSCONFIG_UE4TYPE_H

/**
 * Flags describing a class.
 */
enum EClassFlags
{
	/** No Flags */
	CLASS_None				  = 0x00000000u,
	/** Class is abstract and can't be instantiated directly. */
	CLASS_Abstract            = 0x00000001u,
	/** Save object configuration only to Default INIs, never to local INIs. Must be combined with CLASS_Config */
	CLASS_DefaultConfig		  = 0x00000002u,
	/** Load object configuration at construction time. */
	CLASS_Config			  = 0x00000004u,
	/** This object type can't be saved; null it out at save time. */
	CLASS_Transient			  = 0x00000008u,
	/** Successfully parsed. */
	CLASS_Parsed              = 0x00000010u,
	/** */
	CLASS_MatchedSerializers  = 0x00000020u,
	/** All the properties on the class are shown in the advanced section (which is hidden by default) unless SimpleDisplay is specified on the property */
	CLASS_AdvancedDisplay	  = 0x00000040u,
	/** Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative */
	CLASS_Native			  = 0x00000080u,
	/** Don't export to C++ header. */
	CLASS_NoExport            = 0x00000100u,
	/** Do not allow users to create in the editor. */
	CLASS_NotPlaceable        = 0x00000200u,
	/** Handle object configuration on a per-object basis, rather than per-class. */
	CLASS_PerObjectConfig     = 0x00000400u,
	
	/** Whether SetUpRuntimeReplicationData still needs to be called for this class */
	CLASS_ReplicationDataIsSetUp = 0x00000800u,
	
	/** Class can be constructed from editinline New button. */
	CLASS_EditInlineNew		  = 0x00001000u,
	/** Display properties in the editor without using categories. */
	CLASS_CollapseCategories  = 0x00002000u,
	/** Class is an interface **/
	CLASS_Interface           = 0x00004000u,
	/**  Do not export a constructor for this class, assuming it is in the cpptext **/
	CLASS_CustomConstructor   = 0x00008000u,
	/** all properties and functions in this class are const and should be exported as const */
	CLASS_Const			      = 0x00010000u,

	/** Class flag indicating the class is having its layout changed, and therefore is not ready for a CDO to be created */
	CLASS_LayoutChanging	  = 0x00020000u,
	
	/** Indicates that the class was created from blueprint source material */
	CLASS_CompiledFromBlueprint  = 0x00040000u,

	/** Indicates that only the bare minimum bits of this class should be DLL exported/imported */
	CLASS_MinimalAPI	      = 0x00080000u,
	
	/** Indicates this class must be DLL exported/imported (along with all of it's members) */
	CLASS_RequiredAPI	      = 0x00100000u,

	/** Indicates that references to this class default to instanced. Used to be subclasses of UComponent, but now can be any UObject */
	CLASS_DefaultToInstanced  = 0x00200000u,

	/** Indicates that the parent token stream has been merged with ours. */
	CLASS_TokenStreamAssembled  = 0x00400000u,
	/** Class has component properties. */
	CLASS_HasInstancedReference= 0x00800000u,
	/** Don't show this class in the editor class browser or edit inline new menus. */
	CLASS_Hidden			  = 0x01000000u,
	/** Don't save objects of this class when serializing */
	CLASS_Deprecated		  = 0x02000000u,
	/** Class not shown in editor drop down for class selection */
	CLASS_HideDropDown		  = 0x04000000u,
	/** Class settings are saved to <AppData>/..../Blah.ini (as opposed to CLASS_DefaultConfig) */
	CLASS_GlobalUserConfig	  = 0x08000000u,
	/** Class was declared directly in C++ and has no boilerplate generated by UnrealHeaderTool */
	CLASS_Intrinsic			  = 0x10000000u,
	/** Class has already been constructed (maybe in a previous DLL version before hot-reload). */
	CLASS_Constructed		  = 0x20000000u,
	/** Indicates that object configuration will not check against ini base/defaults when serialized */
	CLASS_ConfigDoNotCheckDefaults = 0x40000000u,
	/** Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists. */
	CLASS_NewerVersionExists  = 0x80000000u,
};



/**
 * Flags used for quickly casting classes of certain types; all class cast flags are inherited
 */
enum EClassCastFlags : uint64_t
{
	CASTCLASS_None = 0x0000000000000000,

	CASTCLASS_UField							= 0x0000000000000001,
	CASTCLASS_UInt8Property						= 0x0000000000000002,
	CASTCLASS_UEnum								= 0x0000000000000004,
	CASTCLASS_UStruct							= 0x0000000000000008,
	CASTCLASS_UScriptStruct						= 0x0000000000000010,
	CASTCLASS_UClass							= 0x0000000000000020,
	CASTCLASS_UByteProperty						= 0x0000000000000040,
	CASTCLASS_UIntProperty						= 0x0000000000000080,
	CASTCLASS_UFloatProperty					= 0x0000000000000100,
	CASTCLASS_UUInt64Property					= 0x0000000000000200,
	CASTCLASS_UClassProperty					= 0x0000000000000400,
	CASTCLASS_UUInt32Property					= 0x0000000000000800,
	CASTCLASS_UInterfaceProperty				= 0x0000000000001000,
	CASTCLASS_UNameProperty						= 0x0000000000002000,
	CASTCLASS_UStrProperty						= 0x0000000000004000,
	CASTCLASS_UProperty							= 0x0000000000008000,
	CASTCLASS_UObjectProperty					= 0x0000000000010000,
	CASTCLASS_UBoolProperty						= 0x0000000000020000,
	CASTCLASS_UUInt16Property					= 0x0000000000040000,
	CASTCLASS_UFunction							= 0x0000000000080000,
	CASTCLASS_UStructProperty					= 0x0000000000100000,
	CASTCLASS_UArrayProperty					= 0x0000000000200000,
	CASTCLASS_UInt64Property					= 0x0000000000400000,
	CASTCLASS_UDelegateProperty					= 0x0000000000800000,
	CASTCLASS_UNumericProperty					= 0x0000000001000000,
	CASTCLASS_UMulticastDelegateProperty		= 0x0000000002000000,
	CASTCLASS_UObjectPropertyBase				= 0x0000000004000000,
	CASTCLASS_UWeakObjectProperty				= 0x0000000008000000,
	CASTCLASS_ULazyObjectProperty				= 0x0000000010000000,
	CASTCLASS_USoftObjectProperty				= 0x0000000020000000,
	CASTCLASS_UTextProperty						= 0x0000000040000000,
	CASTCLASS_UInt16Property					= 0x0000000080000000,
	CASTCLASS_UDoubleProperty					= 0x0000000100000000,
	CASTCLASS_USoftClassProperty				= 0x0000000200000000,
	CASTCLASS_UPackage							= 0x0000000400000000,
	CASTCLASS_ULevel							= 0x0000000800000000,
	CASTCLASS_AActor							= 0x0000001000000000,
	CASTCLASS_APlayerController					= 0x0000002000000000,
	CASTCLASS_APawn								= 0x0000004000000000,
	CASTCLASS_USceneComponent					= 0x0000008000000000,
	CASTCLASS_UPrimitiveComponent				= 0x0000010000000000,
	CASTCLASS_USkinnedMeshComponent				= 0x0000020000000000,
	CASTCLASS_USkeletalMeshComponent			= 0x0000040000000000,
	CASTCLASS_UBlueprint						= 0x0000080000000000,
	CASTCLASS_UDelegateFunction					= 0x0000100000000000,
	CASTCLASS_UStaticMeshComponent				= 0x0000200000000000,
	CASTCLASS_UMapProperty						= 0x0000400000000000,
	CASTCLASS_USetProperty						= 0x0000800000000000,
	CASTCLASS_UEnumProperty						= 0x0001000000000000,
	CASTCLASS_USparseDelegateFunction			= 0x0002000000000000,
	CASTCLASS_UMulticastInlineDelegateProperty	= 0x0004000000000000,
	CASTCLASS_UMulticastSparseDelegateProperty	= 0x0008000000000000,
};


/** 
 * Flags describing an object instance
 */
enum EObjectFlags
{
	// Do not add new flags unless they truly belong here. There are alternatives.
	// if you change any the bit of any of the RF_Load flags, then you will need legacy serialization
	RF_NoFlags					= 0x00000000,	///< No flags, used to avoid a cast

	// This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
	// The garbage collector also tends to look at these.
	RF_Public					=0x00000001,	///< Object is visible outside its package.
	RF_Standalone				=0x00000002,	///< Keep object around for editing even if unreferenced.
	RF_MarkAsNative				=0x00000004,	///< Object (UField) will be marked as native on construction (DO NOT USE THIS FLAG in HasAnyFlags() etc)
	RF_Transactional			=0x00000008,	///< Object is transactional.
	RF_ClassDefaultObject		=0x00000010,	///< This object is its class's default object
	RF_ArchetypeObject			=0x00000020,	///< This object is a template for another object - treat like a class default object
	RF_Transient				=0x00000040,	///< Don't save object.

	// This group of flags is primarily concerned with garbage collection.
	RF_MarkAsRootSet			=0x00000080,	///< Object will be marked as root set on construction and not be garbage collected, even if unreferenced (DO NOT USE THIS FLAG in HasAnyFlags() etc)
	RF_TagGarbageTemp			=0x00000100,	///< This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.

	// The group of flags tracks the stages of the lifetime of a uobject
	RF_NeedInitialization		=0x00000200,	///< This object has not completed its initialization process. Cleared when ~FObjectInitializer completes
	RF_NeedLoad					=0x00000400,	///< During load, indicates object needs loading.
	RF_KeepForCooker			=0x00000800,	///< Keep this object during garbage collection because it's still being used by the cooker
	RF_NeedPostLoad				=0x00001000,	///< Object needs to be postloaded.
	RF_NeedPostLoadSubobjects	=0x00002000,	///< During load, indicates that the object still needs to instance subobjects and fixup serialized component references
	RF_NewerVersionExists		=0x00004000,	///< Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists
	RF_BeginDestroyed			=0x00008000,	///< BeginDestroy has been called on the object.
	RF_FinishDestroyed			=0x00010000,	///< FinishDestroy has been called on the object.

	// Misc. Flags
	RF_BeingRegenerated			=0x00020000,	///< Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport())
	RF_DefaultSubObject			=0x00040000,	///< Flagged on subobjects that are defaults
	RF_WasLoaded				=0x00080000,	///< Flagged on UObjects that were loaded
	RF_TextExportTransient		=0x00100000,	///< Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
	RF_LoadCompleted			=0x00200000,	///< Object has been completely serialized by linkerload at least once. DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
	RF_InheritableComponentTemplate = 0x00400000, ///< Archetype of the object can be in its super class
	RF_DuplicateTransient		=0x00800000,	///< Object should not be included in any type of duplication (copy/paste, binary duplication, etc.)
	RF_StrongRefOnFrame			=0x01000000,	///< References to this object from persistent function frame are handled as strong ones.
	RF_NonPIEDuplicateTransient	=0x02000000,	///< Object should not be included for duplication unless it's being duplicated for a PIE session
	RF_Dynamic					=0x04000000,	///< Field Only. Dynamic field - doesn't get constructed during static initialization, can be constructed multiple times
	RF_WillBeLoaded				=0x08000000,	///< This object was constructed during load and will be loaded shortly
};


/**
 * Flags associated with each property in a class, overriding the
 * property's default behavior.
 * @warning When adding one here, please update ParsePropertyFlags()
 */
enum EPropertyFlags : uint64_t
{
	CPF_None = 0,

	CPF_Edit							= 0x0000000000000001,	///< Property is user-settable in the editor.
	CPF_ConstParm						= 0x0000000000000002,	///< This is a constant function parameter
	CPF_BlueprintVisible				= 0x0000000000000004,	///< This property can be read by blueprint code
	CPF_ExportObject					= 0x0000000000000008,	///< Object can be exported with actor.
	CPF_BlueprintReadOnly				= 0x0000000000000010,	///< This property cannot be modified by blueprint code
	CPF_Net								= 0x0000000000000020,	///< Property is relevant to network replication.
	CPF_EditFixedSize					= 0x0000000000000040,	///< Indicates that elements of an array can be modified, but its size cannot be changed.
	CPF_Parm							= 0x0000000000000080,	///< Function/When call parameter.
	CPF_OutParm							= 0x0000000000000100,	///< Value is copied out after function call.
	CPF_ZeroConstructor					= 0x0000000000000200,	///< memset is fine for construction
	CPF_ReturnParm						= 0x0000000000000400,	///< Return value.
	CPF_DisableEditOnTemplate			= 0x0000000000000800,	///< Disable editing of this property on an archetype/sub-blueprint
	//CPF_      						= 0x0000000000001000,	///< 
	CPF_Transient   					= 0x0000000000002000,	///< Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
	CPF_Config      					= 0x0000000000004000,	///< Property should be loaded/saved as permanent profile.
	//CPF_								= 0x0000000000008000,	///< 
	CPF_DisableEditOnInstance			= 0x0000000000010000,	///< Disable editing on an instance of this class
	CPF_EditConst   					= 0x0000000000020000,	///< Property is uneditable in the editor.
	CPF_GlobalConfig					= 0x0000000000040000,	///< Load config from base class, not subclass.
	CPF_InstancedReference				= 0x0000000000080000,	///< Property is a component references.
	//CPF_								= 0x0000000000100000,	///<
	CPF_DuplicateTransient				= 0x0000000000200000,	///< Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
	CPF_SubobjectReference				= 0x0000000000400000,	///< Property contains subobject references (TSubobjectPtr)
	//CPF_    							= 0x0000000000800000,	///< 
	CPF_SaveGame						= 0x0000000001000000,	///< Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame
	CPF_NoClear							= 0x0000000002000000,	///< Hide clear (and browse) button.
	//CPF_  							= 0x0000000004000000,	///<
	CPF_ReferenceParm					= 0x0000000008000000,	///< Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
	CPF_BlueprintAssignable				= 0x0000000010000000,	///< MC Delegates only.  Property should be exposed for assigning in blueprint code
	CPF_Deprecated  					= 0x0000000020000000,	///< Property is deprecated.  Read it from an archive, but don't save it.
	CPF_IsPlainOldData					= 0x0000000040000000,	///< If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
	CPF_RepSkip							= 0x0000000080000000,	///< Not replicated. For non replicated properties in replicated structs 
	CPF_RepNotify						= 0x0000000100000000,	///< Notify actors when a property is replicated
	CPF_Interp							= 0x0000000200000000,	///< interpolatable property for use with matinee
	CPF_NonTransactional				= 0x0000000400000000,	///< Property isn't transacted
	CPF_EditorOnly						= 0x0000000800000000,	///< Property should only be loaded in the editor
	CPF_NoDestructor					= 0x0000001000000000,	///< No destructor
	//CPF_								= 0x0000002000000000,	///<
	CPF_AutoWeak						= 0x0000004000000000,	///< Only used for weak pointers, means the export type is autoweak
	CPF_ContainsInstancedReference		= 0x0000008000000000,	///< Property contains component references.
	CPF_AssetRegistrySearchable			= 0x0000010000000000,	///< asset instances will add properties with this flag to the asset registry automatically
	CPF_SimpleDisplay					= 0x0000020000000000,	///< The property is visible by default in the editor details view
	CPF_AdvancedDisplay					= 0x0000040000000000,	///< The property is advanced and not visible by default in the editor details view
	CPF_Protected						= 0x0000080000000000,	///< property is protected from the perspective of script
	CPF_BlueprintCallable				= 0x0000100000000000,	///< MC Delegates only.  Property should be exposed for calling in blueprint code
	CPF_BlueprintAuthorityOnly			= 0x0000200000000000,	///< MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
	CPF_TextExportTransient				= 0x0000400000000000,	///< Property shouldn't be exported to text format (e.g. copy/paste)
	CPF_NonPIEDuplicateTransient		= 0x0000800000000000,	///< Property should only be copied in PIE
	CPF_ExposeOnSpawn					= 0x0001000000000000,	///< Property is exposed on spawn
	CPF_PersistentInstance				= 0x0002000000000000,	///< A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
	CPF_UObjectWrapper					= 0x0004000000000000,	///< Property was parsed as a wrapper class like TSubclassOf<T>, FScriptInterface etc., rather than a USomething*
	CPF_HasGetValueTypeHash				= 0x0008000000000000,	///< This property can generate a meaningful hash value.
	CPF_NativeAccessSpecifierPublic		= 0x0010000000000000,	///< Public native access specifier
	CPF_NativeAccessSpecifierProtected	= 0x0020000000000000,	///< Protected native access specifier
	CPF_NativeAccessSpecifierPrivate	= 0x0040000000000000,	///< Private native access specifier
	CPF_SkipSerialization				= 0x0080000000000000,	///< Property shouldn't be serialized, can still be exported to text
};


//
// Function flags.
//
// Note: Please keep ParseFunctionFlags in sync when this enum is modified.
enum EFunctionFlags : uint32_t
{
	// Function flags.
	FUNC_None				= 0x00000000,

	FUNC_Final				= 0x00000001,	// Function is final (prebindable, non-overridable function).
	FUNC_RequiredAPI		= 0x00000002,	// Indicates this function is DLL exported/imported.
	FUNC_BlueprintAuthorityOnly= 0x00000004,   // Function will only run if the object has network authority
	FUNC_BlueprintCosmetic	= 0x00000008,   // Function is cosmetic in nature and should not be invoked on dedicated servers
	// FUNC_				= 0x00000010,   // unused.
	// FUNC_				= 0x00000020,   // unused.
	FUNC_Net				= 0x00000040,   // Function is network-replicated.
	FUNC_NetReliable		= 0x00000080,   // Function should be sent reliably on the network.
	FUNC_NetRequest			= 0x00000100,	// Function is sent to a net service
	FUNC_Exec				= 0x00000200,	// Executable from command line.
	FUNC_Native				= 0x00000400,	// Native function.
	FUNC_Event				= 0x00000800,   // Event function.
	FUNC_NetResponse		= 0x00001000,   // Function response from a net service
	FUNC_Static				= 0x00002000,   // Static function.
	FUNC_NetMulticast		= 0x00004000,	// Function is networked multicast Server -> All Clients
	FUNC_UbergraphFunction	= 0x00008000,   // Function is used as the merge 'ubergraph' for a blueprint, only assigned when using the persistent 'ubergraph' frame
	FUNC_MulticastDelegate	= 0x00010000,	// Function is a multi-cast delegate signature (also requires FUNC_Delegate to be set!)
	FUNC_Public				= 0x00020000,	// Function is accessible in all classes (if overridden, parameters must remain unchanged).
	FUNC_Private			= 0x00040000,	// Function is accessible only in the class it is defined in (cannot be overridden, but function name may be reused in subclasses.  IOW: if overridden, parameters don't need to match, and Super.Func() cannot be accessed since it's private.)
	FUNC_Protected			= 0x00080000,	// Function is accessible only in the class it is defined in and subclasses (if overridden, parameters much remain unchanged).
	FUNC_Delegate			= 0x00100000,	// Function is delegate signature (either single-cast or multi-cast, depending on whether FUNC_MulticastDelegate is set.)
	FUNC_NetServer			= 0x00200000,	// Function is executed on servers (set by replication code if passes check)
	FUNC_HasOutParms		= 0x00400000,	// function has out (pass by reference) parameters
	FUNC_HasDefaults		= 0x00800000,	// function has structs that contain defaults
	FUNC_NetClient			= 0x01000000,	// function is executed on clients
	FUNC_DLLImport			= 0x02000000,	// function is imported from a DLL
	FUNC_BlueprintCallable	= 0x04000000,	// function can be called from blueprint code
	FUNC_BlueprintEvent		= 0x08000000,	// function can be overridden/implemented from a blueprint
	FUNC_BlueprintPure		= 0x10000000,	// function can be called from blueprint code, and is also pure (produces no side effects). If you set this, you should set FUNC_BlueprintCallable as well.
	FUNC_EditorOnly			= 0x20000000,	// function can only be called from an editor scrippt.
	FUNC_Const				= 0x40000000,	// function can be called from blueprint code, and only reads state (never writes state)
	FUNC_NetValidate		= 0x80000000,	// function must supply a _Validate implementation

	FUNC_AllFlags		= 0xFFFFFFFF,
};

enum class EPropertyGenFlags : uint32_t
{
	// First 5 bits are the property type
	Byte					= 0x00,
	Int8					= 0x01,
	Int16					= 0x02,
	Int						= 0x03,
	Int64					= 0x04,
	UInt16					= 0x05,
	UInt32					= 0x06,
	UInt64					= 0x07,
	UnsizedInt				= 0x08,
	UnsizedUInt				= 0x09,
	Float					= 0x0A,
	Double					= 0x0B,
	Bool					= 0x0C,
	SoftClass				= 0x0D,
	WeakObject				= 0x0E,
	LazyObject				= 0x0F,
	SoftObject				= 0x10,
	Class					= 0x11,
	Object					= 0x12,
	Interface				= 0x13,
	Name					= 0x14,
	Str						= 0x15,
	Array					= 0x16,
	Map						= 0x17,
	Set						= 0x18,
	Struct					= 0x19,
	Delegate				= 0x1A,
	InlineMulticastDelegate = 0x1B,
	SparseMulticastDelegate = 0x1C,
	Text					= 0x1D,
	Enum					= 0x1E,

	// 以下, 为自定义类型
	MaxTYPE					= 0x1F,  
	
	Function				= 1000,
	DelegateFunction		= 1001,

	HEX						= 1500,


	None					= 20000,

	unknown					= 20001,
};

typedef  EPropertyGenFlags  EPropertyTYPE;



#pragma pack (1)

struct UE4$FString {
	wchar_t  * _string;
	int        _count;
	int        _max;
};

struct UE4$FArray {
	UObject  ** objects;
	int        _count;
	int        _max;


	UObject  * getBuffer( int kIndex, size_t kSize = sizeof(UObject *)) {
		if (NULL == _count || _count <= kIndex) 
			return NULL;

		uint64_t kBuffer = 0;
		
		kBuffer += (uint64_t)objects;

		kBuffer += (kIndex * kSize);

		return (UObject  *)kBuffer;
	}
};

struct _tagFName {
	int     index;
	int     number;

	_tagFName(const void * name) {
		index = ((int *)name)[0];
		number = ((int *)name)[1];
	}

	_tagFName(uint64_t name) :
		_tagFName(&name) {

	}

	_tagFName() {
		index = 0;
		number = 0;
	}
};



//-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

struct UE4$UObjectBase {
	void **                        vfTable;       //vf表
	/** Flags used to track and report various object states. This needs to be 8 byte aligned on 32-bit platforms to reduce memory waste */
	int32_t                        ObjectFlags;

	/** Index into GObjectArray...very private.   */
	int32_t                        InternalIndex;

	/** Class the object belongs to. */
	UE4$UClass *                   ClassPrivate;

	/** Name of this object */
	uint64_t                        NamePrivate;

	/** Object this object resides in. */
	void	*                       OuterPrivate;
};

typedef UE4$UObjectBase			UE4$UObjectHEAD;

//00000000
//00000000 UField          struc ; (sizeof=0x30, align=0x8, copyof_1122)
//00000000                                         ; XREF: UEnum/r
//00000000                                         ; UStruct/r ...
//00000000 baseclass_0     UObject ?               ; XREF: FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+3E/r
//00000000                                         ; FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+66/w ...
//00000028 Next            dq ?                    ; offset
//00000030 UField          ends

struct UE4$UField : public UE4$UObjectBase {
	UE4$UField *   Next;
};

//00000000 FStructBaseChain struc ; (sizeof=0x10, align=0x8, copyof_1123)
//00000000                                         ; XREF: UStruct/r
//00000000 StructBaseChainArray dq ?               ; offset
//00000008 NumStructBasesInChainMinusOne dd ?
//0000000C                 db ? ; undefined
//0000000D                 db ? ; undefined
//0000000E                 db ? ; undefined
//0000000F                 db ? ; undefined
//00000010 FStructBaseChain ends

struct UE4$FStructBaseChain {
	uint64_t   StructBaseChainArray;
	uint32_t   NumStructBasesInChainMinusOne;
	uint32_t   undefined_sbc;
};

//00000000 UStruct         struc ; (sizeof=0x98, align=0x8, copyof_1124)
//00000000                                         ; XREF: UClass/r
//00000000                                         ; UFunction/r ...
//00000000 baseclass_0     UField ?                ; XREF: FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+3E/r
//00000000                                         ; FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+66/w ...
//00000030 baseclass_30    FStructBaseChain ?
//00000040 SuperStruct     dq ?                    ; offset
//00000048 Children        dq ?                    ; offset
//00000050 PropertiesSize  dd ?
//00000054 MinAlignment    dd ?
//00000058 Script          TArray<unsigned char,TSizedDefaultAllocator<32> > ?
//00000068 PropertyLink    dq ?                    ; offset
//00000070 RefLink         dq ?                    ; offset
//00000078 DestructorLink  dq ?                    ; offset
//00000080 PostConstructLink dq ?                  ; offset
//00000088 ScriptObjectReferences TArray<UObject *,TSizedDefaultAllocator<32> > ?
//00000098 UStruct         ends

struct UE4$UStruct : public UE4$UField, UE4$FStructBaseChain {
	UE4$UStruct *			SuperStruct;
	uint64_t				Children;
	uint32_t				PropertiesSize;
	uint32_t				MinAlignment;

	uint64_t				Script[2];						//FArray<xxx>

	UE4$UProperty *  		PropertyLink;
	UE4$UProperty *			RefLink;
	uint64_t				DestructorLink;
	uint64_t				PostConstructLink;

	uint64_t				ScriptObjectReferences[2];		//FArray<xxx>
};

//00000000 UClass          struc ; (sizeof=0x210, align=0x8, copyof_1163)
//00000000                                         ; XREF: ?FindObjectAndPropOffset@FMatineeUtils@@YAPEAVUObject@@AEAPEAXAEAPEAVUProperty@@PEAV2@VFName@@PEBV?$TArray@PEAVUClass@@V?$TSizedDefaultAllocator@$0CA@@@@@PEBV?$TArray@VFName@@V?$TSizedDefaultAllocator@$0CA@@@@@@Z/r
//00000000                                         ; ?GetInterpBoolPropertyRef@FMatineeUtils@@YAPEAIPEAVAActor@@VFName@@AEAPEAVUBoolProperty@@@Z/r ...
//00000000 baseclass_0     UStruct ?               ; XREF: FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+3E/r
//00000000                                         ; FMatineeUtils::FindObjectAndPropOffset(void * &,UProperty * &,UObject *,FName,TArray<UClass *,TSizedDefaultAllocator<32>> const *,TArray<FName,TSizedDefaultAllocator<32>> const *)+66/w ...
//00000098 ClassConstructor dq ?                   ; offset
//000000A0 ClassVTableHelperCtorCaller dq ?        ; offset
//000000A8 ClassAddReferencedObjects dq ?          ; offset
//000000B0 _bfb0           dd ?
//000000B4 ClassFlags      dd ?                    ; enum EClassFlags
//000000B8 ClassCastFlags  db 8 dup(?)
//000000C0 ClassWithin     dq ?                    ; offset
//000000C8 ClassGeneratedBy dq ?                   ; offset
//000000D0 ClassConfigName FName ?
//000000D8 ClassReps       TArray<FRepRecord,TSizedDefaultAllocator<32> > ?
//000000E8 NetFields       TArray<UField *,TSizedDefaultAllocator<32> > ?
//000000F8 ClassDefaultObject dq ?                 ; offset
//00000100 SparseClassData dq ?                    ; offset
//00000108 SparseClassDataStruct dq ?              ; offset
//00000110 FuncMap         TMap<FName,UFunction *,FDefaultSetAllocator,TDefaultMapHashableKeyFuncs<FName,UFunction *,0> > ?
//00000160 SuperFuncMap    TMap<FName,UFunction *,FDefaultSetAllocator,TDefaultMapHashableKeyFuncs<FName,UFunction *,0> > ?
//000001B0 SuperFuncMapLock FWindowsRWLock ?
//000001B8 Interfaces      TArray<FImplementedInterface,TSizedDefaultAllocator<32> > ?
//000001C8 ReferenceTokenStream FGCReferenceTokenStream ?
//000001D8 ReferenceTokenStreamCritical FWindowsCriticalSection ?
//00000200 NativeFunctionLookupTable TArray<FNativeFunctionLookup,TSizedDefaultAllocator<32> > ?
//00000210 UClass          ends

struct UE4$UClass : public UE4$UStruct {
	uint64_t				ClassConstructor;
	uint64_t				ClassVTableHelperCtorCaller;
	uint64_t				ClassAddReferencedObjects;

	uint32_t				_bfb0;
	uint32_t				ClassFlags;
	uint8_t					ClassCastFlags[8];

	uint64_t				ClassWithin;
	uint64_t				ClassGeneratedBy;
	uint64_t				ClassConfigName;

	uint64_t				ClassReps[2];
	uint64_t				NetFields[2];

	uint64_t				ClassDefaultObject;
	uint64_t				SparseClassData;
	uint64_t				SparseClassDataStruct;

	uint8_t					FuncMap[0x00000050];
	uint8_t					SuperFuncMap[0x00000050];

	uint64_t				SuperFuncMapLock;

	uint64_t				Interfaces[2];

	uint64_t				ReferenceTokenStream[2];
	uint64_t				ReferenceTokenStreamCritical[5];

	uint64_t				NativeFunctionLookupTable[2];

	//获取 父级类指针
	UE4$UClass * _2SuperUClass() { return (UE4$UClass *)SuperStruct; }

	//获取 函数列表数组对象
	UE4$FArray * _2UFunctionArray() { return (UE4$FArray *)FuncMap; }



};

//00000000 UProperty       struc ; (sizeof=0x70, align=0x8, copyof_1127)
//00000000                                         ; XREF: UBoolProperty/r
//00000000                                         ; UStructProperty/r
//00000000 baseclass_0     UField ?
//00000030 ArrayDim        dd ?
//00000034 ElementSize     dd ?
//00000038 PropertyFlags   db 8 dup(?)
//00000040 RepIndex        dw ?
//00000042 BlueprintReplicationCondition TEnumAsByte<enum ELifetimeCondition> ?
//00000043                 db ? ; undefined
//00000044 Offset_Internal dd ?
//00000048 RepNotifyFunc   FName ?
//00000050 PropertyLinkNext dq ?                   ; offset
//00000058 NextRef         dq ?                    ; offset
//00000060 DestructorLinkNext dq ?                 ; offset
//00000068 PostConstructLinkNext dq ?              ; offset
//00000070 UProperty       ends

struct UE4$UProperty : public UE4$UField {
	uint32_t				ArrayDim;
	uint32_t				ElementSize;
	EPropertyFlags			PropertyFlags;

	uint16_t				RepIndex;
	uint8_t					BlueprintReplicationCondition;
	uint8_t					undefined_p;

	uint32_t				Offset_Internal;
	uint64_t				RepNotifyFunc;
	uint64_t				PropertyLinkNext;

	uint64_t				NextRef;
	uint64_t				DestructorLinkNext;
	uint64_t				PostConstructLinkNext;

	UE4$UProperty * _2NextProperty() {
		return (UE4$UProperty *)Next;
	};
};

//00000000 UObjectPropertyBase struc ; (sizeof=0x78, align=0x8, copyof_8056)
//00000000                                         ; XREF: TProperty<FSoftObjectPtr,UObjectPropertyBase>/r
//00000000 baseclass_0     UProperty ?
//00000070 PropertyClass   dq ?                    ; offset
//00000078 UObjectPropertyBase ends

struct UE4$UObjectPropertyBase : public UE4$UProperty {
	void *			PropertyClass;
};

//00000000 UBoolProperty   struc ; (sizeof=0x78, align=0x8, copyof_26002)
//00000000 baseclass_0     UProperty ?
//00000070 FieldSize       db ?
//00000071 ByteOffset      db ?
//00000072 ByteMask        db ?
//00000073 FieldMask       db ?
//00000074                 db ? ; undefined
//00000075                 db ? ; undefined
//00000076                 db ? ; undefined
//00000077                 db ? ; undefined
//00000078 UBoolProperty   ends

struct UE4$UBoolProperty : public UE4$UProperty {
	uint8_t				FieldSize;
	uint8_t				ByteOffset;
	uint8_t				ByteMask;
	uint8_t				FieldMask;

	uint32_t			undefined_bp;
};

//00000000 UMapProperty    struc ; (sizeof=0x98, align=0x8, copyof_5631)
//00000000 baseclass_0     TProperty<FScriptMap,UProperty> ?
//00000070 KeyProp         dq ?                    ; offset
//00000078 ValueProp       dq ?                    ; offset
//00000080 MapLayout       FScriptMapLayout ?
//00000098 UMapProperty    ends

struct UE4$UMapProperty : public UE4$UProperty {
	uint64_t			KeyProp;
	uint64_t			ValueProp;
	uint64_t			MapLayout[3];
};

//00000000 USetProperty    struc ; (sizeof=0x90, align=0x8, copyof_21528)
//00000000 baseclass_0     TProperty<FScriptSet,UProperty> ?
//00000070 ElementProp     dq ?                    ; offset
//00000078 SetLayout       FScriptSetLayout ?
//0000008C                 db ? ; undefined
//0000008D                 db ? ; undefined
//0000008E                 db ? ; undefined
//0000008F                 db ? ; undefined
//00000090 USetProperty    ends

struct UE4$USetProperty : public UE4$UProperty {
	uint64_t			ElementProp;
	uint64_t			SetLayout[3];
};

//00000000 UStructProperty struc ; (sizeof=0x78, align=0x8, copyof_2287)
//00000000 baseclass_0     UProperty ?
//00000070 Struct          dq ?                    ; offset
//00000078 UStructProperty ends
//00000078

struct UE4$UStructProperty : public UE4$UProperty {
	UE4$UStruct *		Struct;
};

//00000000 UEnumProperty   struc ; (sizeof=0x80, align=0x8, copyof_27648)
//00000000 baseclass_0     UProperty ?
//00000070 UnderlyingProp  dq ?                    ; offset
//00000078 Enum            dq ?                    ; offset
//00000080 UEnumProperty   ends

struct UE4$UEnumProperty : public UE4$UProperty {
	uint64_t			UnderlyingProp;
	UE4$UEnum	*		Enum;
};


//00000000 UInterfaceProperty struc ; (sizeof=0x78, align=0x8, copyof_21496)
//00000000 baseclass_0     TProperty<FScriptInterface,UProperty> ?
//00000070 InterfaceClass  dq ?                    ; offset
//00000078 UInterfaceProperty ends

struct UE4$UInterfaceProperty : public UE4$UProperty {
	void *			InterfaceClass;
};



//00000000 USoftClassProperty struc ; (sizeof=0x80, align=0x8, copyof_26063)
//00000000 baseclass_0     USoftObjectProperty ?
//00000078 MetaClass       dq ?                    ; offset
//00000080 USoftClassProperty ends

struct UE4$USoftClassProperty : public UE4$UObjectPropertyBase {
	void *			MetaClass;
};


//00000000 UClassProperty  struc ; (sizeof=0x80, align=0x8, copyof_17737)
//00000000 baseclass_0     UObjectProperty ?
//00000078 MetaClass       dq ?                    ; offset
//00000080 UClassProperty  ends
//00000080

struct UE4$UClassProperty : public UE4$UObjectPropertyBase {
	void *			MetaClass;
};

//00000000 UObjectProperty struc ; (sizeof=0x78, align=0x8, copyof_9073)
//00000000                                         ; XREF: UClassProperty/r
//00000000 baseclass_0     TUObjectPropertyBase<UObject *> ?
//00000078 UObjectProperty ends

struct UE4$UObjectProperty : public UE4$UObjectPropertyBase {

};

//00000000 UEnum           struc ; (sizeof=0x60, align=0x8, copyof_5515)
//00000000                                         ; XREF: ?execGetEnumeratorName@UKismetNodeHelperLibrary@@SAXPEAVUObject@@AEAUFFrame@@QEAX@Z/r
//00000000 baseclass_0     UField ?
//00000030 CppType         FString ?
//00000040 Names           TArray<TTuple<FName,__int64>,TSizedDefaultAllocator<32> > ?
//00000050 CppForm         dd ?                    ; enum UEnum::ECppForm
//00000054                 db ? ; undefined
//00000055                 db ? ; undefined
//00000056                 db ? ; undefined
//00000057                 db ? ; undefined
//00000058 EnumDisplayNameFn dq ?                  ; offset
//00000060 UEnum           ends

struct UE4$UEnum : public UE4$UField {
	UE4$FString           CppType;
	UE4$FArray            Names;
	uint32_t              CppForm[2];
	uint64_t              EnumDisplayNameFn;

private:
	uint64_t * _2NameBuffer( int index ) {
		if (index >= Names._count)
			return NULL;

		uint64_t * TMPBuffer = NULL;

		//+0x0040 : 0x00000177381BB980 
		//+0x0048 : 0x0000001800000004 
		TMPBuffer = (uint64_t *)Names.objects;

		//--[[ 当前调试信息: address = 0x00000177381BB980 ]]--
		//
		//+0x0000 : 0x00000000000A90BC 
		//+0x0008 : 0x0000000000000000 
		//+0x0010 : 0x00000000000A90CC 
		//+0x0018 : 0x0000000000000001 
		//+0x0020 : 0x00000000000A90DA 
		//+0x0028 : 0x0000000000000002 
		//+0x0030 : 0x00000000000A90F5 
		//+0x0038 : 0x0000000000000003 
		TMPBuffer += (index * 2);

		//返回 buffer 头
		return TMPBuffer;
	}

public:
	uint64_t  I2FName( int index ) {

		uint64_t * TMPBuffer = NULL; 
		if (NULL == (TMPBuffer = _2NameBuffer(index)))
			return 0;

		//取值, 并且返回
		return (uint64_t)TMPBuffer[0];
	}
	uint64_t  I2Value( int index ) {
		uint64_t * TMPBuffer = NULL;
		if (NULL == (TMPBuffer = _2NameBuffer(index)))
			return 0;

		//取值, 并且返回
		return (uint64_t)TMPBuffer[1];
	}
};


//00000000 UFunction       struc ; (sizeof=0xC8, align=0x8, copyof_2288)
//00000000 baseclass_0     UStruct ?
//00000098 FunctionFlags   dd ?                    ; enum EFunctionFlags
//0000009C NumParms        db ?
//0000009D                 db ? ; undefined
//0000009E ParmsSize       dw ?
//000000A0 ReturnValueOffset dw ?
//000000A2 RPCId           dw ?
//000000A4 RPCResponseId   dw ?
//000000A6                 db ? ; undefined
//000000A7                 db ? ; undefined
//000000A8 FirstPropertyToInit dq ?                ; offset
//000000B0 EventGraphFunction dq ?                 ; offset
//000000B8 EventGraphCallOffset dd ?
//000000BC                 db ? ; undefined
//000000BD                 db ? ; undefined
//000000BE                 db ? ; undefined
//000000BF                 db ? ; undefined
//000000C0 Func            dq ?                    ; offset
//000000C8 UFunction       ends
//000000C8

struct UE4$UFunction : public UE4$UStruct {
	uint32_t			FunctionFlags;
	uint16_t			NumParms;

	uint16_t			ParmsSize;
	uint16_t			ReturnValueOffset;

	uint16_t			RPCId;
	uint32_t			RPCResponseId;
	uint64_t			FirstPropertyToInit;
	uint64_t			EventGraphFunction;
	uint64_t			EventGraphCallOffset;

	void *				Func;
};


//+0x0110 : 0x0000027FE1DC8AD0 -- UClass -> FuncMap
//+0x0118 : 0x0000000300000003 
//--[[ 当前调试信息: address = 0x0000027FE1DC8AD0 ]]--
//
//+0x0000 : 0x00000000001272F5 
//+0x0008 : 0x0000027FE321B840 
//+0x0010 : 0x00000000FFFFFFFF 
//+0x0018 : 0x000000000004F7E8 
//+0x0020 : 0x0000027FE321CE20 
//+0x0028 : 0x0000000000000000 
//+0x0030 : 0x000000000004F7E2 
//+0x0038 : 0x0000027FE321C9C0 
//+0x0040 : 0x0000000000000001 
//+0x0048 : 0x0000000000000000 
struct UE4$UFunctionMAP {
	uint64_t			FunName;
	void *				uFunction;
	uint64_t			undefined;
};


/** Objects flags for internal use (GC, low level UObject code) */
enum class EInternalObjectFlags : int32_t {
	None				= 0,				//~ All the other bits are reserved, DO NOT ADD NEW FLAGS HERE!

	ReachableInCluster	= 1 << 23,			//< External reference to object in cluster exists
	ClusterRoot			= 1 << 24,			//< Root of a cluster
	Native				= 1 << 25,			//< Native (UClass only). 
	Async				= 1 << 26,			//< Object exists only on a different thread than the game thread.
	AsyncLoading		= 1 << 27,			//< Object is being asynchronously loaded.
	Unreachable			= 1 << 28,			//< Object is not reachable on the object graph.
	PendingKill			= 1 << 29,			//< Objects that are pending destruction (invalid for gameplay but valid objects)
	RootSet				= 1 << 30,			//< Object will not be garbage collected, even if unreferenced.

	//~ UnusedFlag = 1 << 31,

	GarbageCollectionKeepFlags = Native | Async | AsyncLoading,

	//~ Make sure this is up to date!
	AllFlags = ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet
};

struct UE4$GUObjectINFO{
	UObject *		_kUObject;
	uint32_t        _Flags;
	uint32_t        _ObjectSerialNumber;

	//对应: FUObjectItem::IsPendingKill()
	bool IsPendingKill() { return !!(_Flags & int32_t(EInternalObjectFlags::PendingKill));}

	//检测对象是否有效
	bool IsValid() { return NULL != _kUObject && !IsPendingKill(); }

	uint64_t       _unknown;
};


#pragma pack ()
#endif
